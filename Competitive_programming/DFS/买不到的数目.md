小明开了一家糖果店。
他别出心裁：把水果糖包成4颗一包和7颗一包的两种。
糖果不能拆包卖。
小朋友来买糖的时候，他就用这两种包装来组合。
当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。
你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。
大于17的任何数字都可以用4和7组合出来。
本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。


输入格式  
两个正整数 n,m表示每种包装中糖的颗数。
输出格式  
一个正整数，表示最大不能买到的糖数。
数据范围  
2≤n,m≤1000  
保证数据一定有解。
输入样例：  
```
4 7
```
输出样例：  
```
17
```
  
难度：简单  
时/空限制：1s / 64MB  
来源：第四届蓝桥杯省赛C++A组,第四届蓝桥杯省赛JAVAC组  
算法标签: 数学    
### 题目分析：

首先尽力分析一下，假设d = （a, b）>1，a, b最大公约数大于1，是一定没有答案的，比如说6 和2，最大公约数2，那么不是2的倍数的数都凑不出来，那么这样就没有最大的凑不出来的数了，这样也就没有答案了，但是题目说了，保证一定有解，这种情况也就不需要考虑了。

进一步的分析比较困难，可以采用打表找规律的方法

这里提一个定理，裵蜀定理，若a,b是整数,且gcd(a, b)=d，那么对于任意的整数x, y, ax+by都一定是d的倍数，特别地，一定存在整数x, y，使ax+by=d成立。

暴力打表的写法：
``` C++
#include<iostream>

using namespace std;

bool dfs(int m, int p, int q)
{
    if(!m) return true;
    
    if(m>=p && dfs(m-p, p, q)) return true;
    if(m>=q && dfs(m-q, p, q)) return true;
    
    return false;
}

int main()
{
    int p, q;
    cin>>p>>q;
    int res = 0;
    for(int i = 1; i<=1000; i++)
    {
        if(!dfs(i, p, q)) res = i;
    }
    
    printf("%d\n", res);
    
    return 0;
}
```
通过找规律可以得到，如果（p, q）=d=1(互质), 最大的凑不出来的数是(p-1)*(q-1)-1.

这个可以看作是一个定理

最后代码：
``` C++
#include<iostream>

using namespace std;

int main()
{
    int p, q;
    cin>>p>>q;
    
    cout<<(p-1)*(q-1)-1<<endl;
    
    return 0;
}
```
