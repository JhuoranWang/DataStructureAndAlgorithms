## 例题2 最长上升子序列问题

### 2.1 题目

给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。

**输入格式**

第一行包含整数N。

第二行包含N个整数，表示完整序列。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

1≤N≤1000，−10^9≤数列中的数≤10^9

**输入样例：**

```
7
3 1 2 1 8 5 6
```

**输出样例：**

```
4
```

### 2.2 思路

比如样例中的序列，最长的上升子序列是1，2，5，6，也就是说不一定要连续。动态规划的题，还是老样子，考虑状态表示和状态计算。状态表示需要考虑用几维数组表示，一般是从小到大尝试，一维不行就二维，以此类推。这里发现，只需要一维就可以表示了，就是$f(i)$表示所有以第$i$个数结尾的上升子序列中的最大值。之后我们要考虑集合，也就是，所有以第$i$个数结尾的所有上升子序列。接下来是状态计算，也就是一个集合划分的过程，考虑一下第$i$个数的前一个数的情况，发现可以将前一个数的情况进行集合划分，第$i$个数的前一个数可能是第0个，第1个……第$i-$1个，当然这些前序的数不一定都满足“上升子序列”的条件，这样我们就得到了集合划分的方式。

### 2.3 时间复杂度分析

根据上面的公式，由于我们的状态表示是一维的，状态转移的复杂度也是$O(n)$, 因此，该算法的时间复杂度是$O(n^2)$

### 2.4 Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;
int n;
int a[N];
int f[N];

int main(){
    scanf("%d", &n);
    
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    
    for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1; // 只有a[i]一个数
        for (int j = 1; j < i; j ++ )
            if (a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
    }
    
    int res = 0;
    
    for(int i = 1; i<=n; i++) res = max(f[i], res);
    
    printf("%d\n", res);
    
    return 0;
}
```
