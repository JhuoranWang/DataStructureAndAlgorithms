## 例题3 最长公共子序列问题

### 3.1 题目

给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。

**输入格式**

第一行包含两个整数N和M。

第二行包含一个长度为N的字符串，表示字符串A。

第三行包含一个长度为M的字符串，表示字符串B。

字符串均由小写字母构成。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

1≤N,M≤1000

**输入样例：**

```
4 5
acbd
abedc
```

**输出样例：**

```
3
```

### 3.2 思路

思路和之前的DP一样，分为状态表示f(i,j)和状态计算。状态表示分为了集合和属性两部分，这里的集合就是所有由第一个序列的前i个字母，和第二个序列的前j个字母构成的公共子序列，换句话说就是，所有在第一个序列的前$i$个字母中出现，且在第二个序列的前$j$个字母中出现的子序列。属性很明显就是$max$，集合中最长的子序列的长度。

本题的难点在集合的划分上，假设第一个字符串是$a$, 第二个字符串是b, 我们的划分依据是a[i]和b[j]是否在子序列中，这里就根据选a[i]还是b[j]出现了4种情况，选与不选用1和0表示。第一种情况（00的情况）是指，所有在第一个序列的前$i-1$个字母中出现，且在第二个序列的前$j-1$个字母中出现的子序列，也就是可以直接用$f(i-1,j-1)$来表示。最后一种情况（11的情况）也比较好理解，就是同时包含$a[i]$和$b[j]$的时候，也就是可以把当前的公共项去掉先考虑前面的，最后再加上1，也就是$f(i-1,j-1)+1$. 中间两种的情况的分析却不太相同，$f(i-1,j)$是说，所有在第一个序列的前$i-1$个字母中出现，且在第二个序列的前$j$个字母中出现的子序列，但是这样并不一定包含$b[j]$，然而01这种情况要求必须要选$b[j]$, 也可以理解为，“可有这一项也可以没有这一项”这个集合包含了“一定有这一项”，然而重复数据并不一定会影响属性为最值的状态表示的DP问题的最终答案（虽然集合不是正确的，但是对最终结果没有影响）


同时可以认识到，f(i-1,j-1)这种情况被包含在了f(i-1,j)和f(i,j-1)这两个情况中，所以一般的题解为了简洁都会直接忽略这种情况。

### 3.3 Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main(){
    
    scanf("%d%d", &n, &m);
    scanf("%s%s", a + 1, b + 1);
    
    for(int i = 1; i<=n; i++){
        for(int j = 1; j<=m; j++){
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if(a[i]==b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    }
    
    printf("%d\n", f[n][m]);
    
    return 0;
}
```
